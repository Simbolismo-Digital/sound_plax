<%!-- tutorials on know how to audio --%>
<%!-- https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API/Using_the_MediaStream_Recording_API --%>
Hi Process <%= @pid %>

<div class="audio_stream">
  <br />
  <b>Microfone Stream</b>

  <p>fale e se ou√ßa falando</p>

  <script>
    let listenCurrentUser = true;

    const currentUser = Date();

    const users = new Map();

    // split user channels
    const retrieveChannel = (user) => {
        if (user in users) {
            return users[user];
        } else {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const channel = {
                inputBuffer: [],
                audioContext: audioContext,
                audioBuffer: audioContext.createBuffer(1, 8192, audioContext.sampleRate)
            };
            users[user] = channel;
            return channel;
        }
    }
    // unconditional play PCM data
    const play = (channel) => {
        const {audioContext, audioBuffer, inputBuffer} = channel;
        const base64String = inputBuffer.shift();
        const buffer = decodeBase642PCM(base64String);
        const view = new DataView(buffer);
        const channelData = audioBuffer.getChannelData(0);
        for (let i = 0; i < buffer.byteLength / 2; i++) {
            const sample = view.getInt16(i * 2, true); // true for little-endian
            channelData[i] = sample / 0x7FFF; // Convert back to range -1 to 1
        }
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start();
    };
    
    // buffer and play if its the first
    const bufferAndStart = (user, audioPCM) => {
        if (user != currentUser || listenCurrentUser) {
            channel = retrieveChannel(user);
            channel.inputBuffer.push(audioPCM);
            // start play if first data
            if (channel.inputBuffer.length === 1) {
                play(channel);
            }
        }
    }

    function decodeBase642PCM(base64String) {
        const bytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0)); // Decode Base64 string to Uint8Array
        const buffer = new ArrayBuffer(bytes.length);
        const view = new DataView(buffer);
        for (let i = 0; i < bytes.length; i++) {
            view.setUint8(i, bytes[i]);
        }
        return buffer;
    }

    function encodePCM2base64(audioData) {
        const buffer = new ArrayBuffer(audioData.length * 2); // 16-bit PCM
        const view = new DataView(buffer);
        for (let i = 0; i < audioData.length; i++) {
            let sample = audioData[i];
            // Clamp values between -1 and 1
            sample = Math.max(-1, Math.min(1, sample));
            // Convert to 16-bit PCM (range -32768 to 32767)
            view.setInt16(i * 2, sample * 0x7FFF, true); // true for little-endian
        }
        // Convert the ArrayBuffer to a Uint8Array
        const bytes = new Uint8Array(buffer);
        // Convert the Uint8Array to a Base64 encoded string
        const base64String = btoa(String.fromCharCode.apply(null, bytes));
        return base64String;
    }

    // Function to serialize PCM audio data
    function serializePCM(audioData) {
        const bytes = new Uint8Array(audioData.byteLength);
        const view = new DataView(audioData);
        for (let i = 0; i < view.byteLength; i++) {
            bytes[i] = view.getUint8(i);
        }
        return bytes;
    }

        // Get user media stream for audio input
        navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
            const recorderContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create media stream source node
            const source = recorderContext.createMediaStreamSource(stream);
            
            // Create script processor node to process audio data
            const scriptNode = recorderContext.createScriptProcessor(4096, 1, 1);

            // Process audio data
            scriptNode.onaudioprocess = function(event) {
                const audioData = event.inputBuffer.getChannelData(0); // Get audio data
                const encodedData = encodePCM2base64(audioData); // Encode audio data
                roomChannel.push("send_audio_data", {user: currentUser, body: encodedData}); // Send audio data over WebSocket
            };

            // Connect nodes
            source.connect(scriptNode);
            scriptNode.connect(recorderContext.destination);


        setTimeout(() => {
            // receive packages from network (pre declared audioStreamSocket)
            audioStreamSocket.onMessage(({event, payload}) => {
                console.log("Receiving", payload.user, event);
                if (event === "room:lobby:broadcast_audio_data") bufferAndStart(payload.user, payload.body);
            });
        }, 1000);
        })
    .catch(function(error) {
        console.error("Error accessing microphone:", error);
    });
  </script>
</div>
